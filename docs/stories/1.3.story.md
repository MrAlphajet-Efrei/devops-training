# Story 1.3: PostgreSQL Database Setup

## Status

**Draft**

---

## Story

**As a** DevOps engineer,
**I want** a PostgreSQL database with initial schema,
**so that** the API can persist and retrieve data.

---

## Acceptance Criteria

1. Database initialization script exists in `apps/api/db/` or `infra/db/`
2. Schema includes at least one table (e.g., `items` with id, name, created_at)
3. API connects to PostgreSQL using environment variables for configuration
4. API has a simple CRUD endpoint (e.g., `GET/POST /items`) to validate DB connectivity
5. Database connection is properly pooled and handles reconnection
6. Integration test validates API ↔ Database communication

---

## Tasks / Subtasks

- [ ] **Task 1: Create Database Initialization Scripts** (AC: 1, 2)
  - [ ] Create `apps/api/db/` directory
  - [ ] Create `apps/api/db/init.sql` with schema DDL
  - [ ] Add UUID extension creation (`CREATE EXTENSION IF NOT EXISTS "uuid-ossp"`)
  - [ ] Create `items` table with columns: id, name, description, created_at, updated_at
  - [ ] Add indexes on `created_at` and `name`
  - [ ] Add `update_updated_at_column` trigger function
  - [ ] Create trigger for auto-updating `updated_at`

- [ ] **Task 2: Add Database Dependencies** (AC: 3, 5)
  - [ ] Add SQLAlchemy dependency (`sqlalchemy>=2.0.0`)
  - [ ] Add asyncpg driver (`asyncpg>=0.29.0`)
  - [ ] Add psycopg2-binary for sync operations (`psycopg2-binary>=2.9.0`)
  - [ ] Update `pyproject.toml` with new dependencies

- [ ] **Task 3: Create Database Session Management** (AC: 3, 5)
  - [ ] Create `src/app/db/session.py`
  - [ ] Configure SQLAlchemy engine with connection pooling
  - [ ] Set pool_size=5, max_overflow=10, pool_pre_ping=True
  - [ ] Implement async session factory
  - [ ] Create dependency for injecting DB session into routes

- [ ] **Task 4: Create SQLAlchemy ORM Models** (AC: 2)
  - [ ] Create `src/app/db/models.py`
  - [ ] Define `Item` model with SQLAlchemy
  - [ ] Map model to `items` table
  - [ ] Include all columns and constraints

- [ ] **Task 5: Create Pydantic Schemas for Items** (AC: 4)
  - [ ] Create `src/app/models/item.py`
  - [ ] Define `ItemBase` schema (name, description)
  - [ ] Define `ItemCreate` schema for POST requests
  - [ ] Define `ItemUpdate` schema for PUT requests
  - [ ] Define `Item` response schema with all fields
  - [ ] Define `ItemListResponse` schema

- [ ] **Task 6: Create Item Repository** (AC: 4, 5)
  - [ ] Create `src/app/db/repositories/` directory
  - [ ] Create `src/app/db/repositories/item.py`
  - [ ] Implement `get_all(limit, offset)` method
  - [ ] Implement `get_by_id(id)` method
  - [ ] Implement `create(item_in)` method
  - [ ] Implement `update(id, item_in)` method
  - [ ] Implement `delete(id)` method

- [ ] **Task 7: Implement Items API Endpoints** (AC: 4)
  - [ ] Create `src/app/api/routes/items.py`
  - [ ] Implement `GET /items` - list items with pagination
  - [ ] Implement `POST /items` - create new item
  - [ ] Implement `GET /items/{id}` - get single item
  - [ ] Implement `PUT /items/{id}` - update item
  - [ ] Implement `DELETE /items/{id}` - delete item
  - [ ] Add routes to main router

- [ ] **Task 8: Update Ready Endpoint** (AC: 3)
  - [ ] Modify `/ready` endpoint to actually check database connection
  - [ ] Execute simple query (`SELECT 1`) to verify connectivity
  - [ ] Return 200 if successful, 503 if connection fails

- [ ] **Task 9: Write Integration Tests** (AC: 6)
  - [ ] Create `tests/test_items.py`
  - [ ] Test `POST /items` creates item in database
  - [ ] Test `GET /items` returns created items
  - [ ] Test `GET /items/{id}` returns specific item
  - [ ] Test `PUT /items/{id}` updates item
  - [ ] Test `DELETE /items/{id}` removes item
  - [ ] Test 404 for non-existent items

---

## Dev Notes

### Database Schema (SQL DDL)

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Items table
CREATE TABLE items (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name            VARCHAR(255) NOT NULL,
    description     TEXT,
    created_at      TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at      TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    CONSTRAINT items_name_not_empty CHECK (LENGTH(TRIM(name)) > 0)
);

-- Indexes
CREATE INDEX idx_items_created_at ON items (created_at DESC);
CREATE INDEX idx_items_name ON items (name);

-- Auto-update trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_items_updated_at
    BEFORE UPDATE ON items
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

### SQLAlchemy ORM Model

```python
# src/app/db/models.py
from sqlalchemy import Column, String, Text, DateTime, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_base
from uuid import uuid4
from datetime import datetime

Base = declarative_base()

class Item(Base):
    __tablename__ = "items"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow)
    updated_at = Column(DateTime(timezone=True), nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)

    __table_args__ = (
        CheckConstraint("LENGTH(TRIM(name)) > 0", name="items_name_not_empty"),
    )
```

### Pydantic Schemas

```python
# src/app/models/item.py
from datetime import datetime
from uuid import UUID
from pydantic import BaseModel, Field

class ItemBase(BaseModel):
    name: str = Field(..., max_length=255)
    description: str | None = None

class ItemCreate(ItemBase):
    pass

class ItemUpdate(BaseModel):
    name: str | None = Field(None, max_length=255)
    description: str | None = None

class Item(ItemBase):
    id: UUID
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class ItemListResponse(BaseModel):
    items: list[Item]
    total: int
```

### Connection Configuration

```python
# src/app/db/session.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.config import settings

engine = create_engine(
    settings.database_url,
    pool_size=5,
    max_overflow=10,
    pool_pre_ping=True,
    pool_recycle=300,
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### API Endpoints Reference

| Method | Path | Purpose | Request | Response |
|--------|------|---------|---------|----------|
| `GET` | `/items` | List items | `?limit=100&offset=0` | `ItemListResponse` |
| `POST` | `/items` | Create item | `ItemCreate` | `Item` (201) |
| `GET` | `/items/{id}` | Get item | - | `Item` or 404 |
| `PUT` | `/items/{id}` | Update item | `ItemUpdate` | `Item` or 404 |
| `DELETE` | `/items/{id}` | Delete item | - | 204 or 404 |

### Updated Source Tree

```
apps/api/
├── src/
│   └── app/
│       ├── __init__.py
│       ├── main.py
│       ├── config.py
│       ├── api/
│       │   ├── __init__.py
│       │   ├── router.py
│       │   ├── deps.py             # Database dependency injection
│       │   └── routes/
│       │       ├── __init__.py
│       │       ├── health.py
│       │       └── items.py        # NEW: Items CRUD endpoints
│       ├── models/
│       │   ├── __init__.py
│       │   ├── health.py
│       │   └── item.py             # NEW: Pydantic schemas
│       └── db/
│           ├── __init__.py
│           ├── session.py          # NEW: Session management
│           ├── models.py           # NEW: SQLAlchemy models
│           └── repositories/
│               ├── __init__.py
│               └── item.py         # NEW: Data access layer
├── db/
│   └── init.sql                    # NEW: Schema initialization
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   ├── test_health.py
│   └── test_items.py               # NEW: Integration tests
├── pyproject.toml
└── README.md
```

### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `DB_HOST` | localhost | PostgreSQL host |
| `DB_PORT` | 5432 | PostgreSQL port |
| `DB_NAME` | devops_demo | Database name |
| `DB_USER` | app_user | Database username |
| `DB_PASSWORD` | - | Database password (required) |

### Dependencies on Previous Stories

- **Story 1.1**: Project structure must exist
- **Story 1.2**: FastAPI application with health endpoints

### Key Constraints

- **Type Safety**: Pydantic for all API I/O
- **Naming**: Database tables use snake_case
- **Connection Pooling**: Required for production-readiness
- **Secrets**: Database password from environment variable

### Important Implementation Notes

1. Use repository pattern for data access layer
2. Connection pooling with `pool_pre_ping=True` for resilience
3. The `/ready` endpoint should now actually verify database connectivity
4. All database operations should handle exceptions gracefully
5. Use async/await patterns where appropriate

---

## Testing

### Testing Requirements

| Test Type | Coverage Target | Framework |
|-----------|-----------------|-----------|
| Unit Tests | CRUD operations | pytest + httpx |
| Integration Tests | API ↔ Database | pytest + test database |

### Test Database Setup

For integration tests, use a separate test database or use pytest fixtures to set up/tear down data.

```python
# tests/conftest.py (extended)
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.db.models import Base
from app.main import create_app
from app.db.session import get_db

TEST_DATABASE_URL = "postgresql://test_user:test_pass@localhost:5432/test_db"

@pytest.fixture(scope="session")
def test_engine():
    engine = create_engine(TEST_DATABASE_URL)
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)
```

### Test Scenarios

1. **test_create_item** - POST creates and returns item with 201
2. **test_list_items** - GET returns paginated list
3. **test_get_item_by_id** - GET returns specific item
4. **test_get_item_not_found** - GET returns 404 for invalid ID
5. **test_update_item** - PUT updates and returns item
6. **test_delete_item** - DELETE returns 204
7. **test_ready_with_db** - /ready returns 200 with working database

### Test Commands

```bash
# Run integration tests (requires database)
pytest tests/test_items.py -v

# Run with coverage
pytest -v --cov=app --cov-report=term-missing
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-26 | 1.0 | Initial story draft | SM Bob |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
