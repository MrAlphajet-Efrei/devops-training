# Story 1.6: Docker Compose Local Stack

## Status

**Approved**

---

## Story

**As a** DevOps engineer,
**I want** a docker-compose configuration that runs all services together,
**so that** I can develop and test the complete stack locally.

---

## Acceptance Criteria

1. `docker-compose.yaml` defines all three services (api, frontend, postgres)
2. Services are connected via Docker network
3. PostgreSQL data persists via named volume
4. Environment variables are managed via `.env` file (with `.env.example` template)
5. `docker-compose up` starts all services successfully
6. Frontend can reach API, API can reach Database
7. Health checks are defined for each service
8. `docker-compose down -v` cleanly removes all resources

---

## Tasks / Subtasks

- [ ] **Task 1: Create Docker Compose File** (AC: 1, 2)
  - [ ] Create `apps/docker-compose.yaml`
  - [ ] Define `api` service using local Dockerfile
  - [ ] Define `frontend` service using local Dockerfile
  - [ ] Define `postgres` service using official image
  - [ ] Create custom bridge network `devops-network`
  - [ ] Connect all services to the network

- [ ] **Task 2: Configure PostgreSQL Service** (AC: 3)
  - [ ] Use `postgres:15-alpine` image
  - [ ] Define named volume `postgres_data`
  - [ ] Set environment variables for credentials
  - [ ] Mount init.sql for schema initialization
  - [ ] Expose port 5432 for local access

- [ ] **Task 3: Configure API Service** (AC: 6, 7)
  - [ ] Build from `./api` directory
  - [ ] Set database environment variables
  - [ ] Add `depends_on` for postgres with health condition
  - [ ] Define health check using `/health` endpoint
  - [ ] Expose port 8000

- [ ] **Task 4: Configure Frontend Service** (AC: 6, 7)
  - [ ] Build from `./frontend` directory
  - [ ] Set `NEXT_PUBLIC_API_URL` environment variable
  - [ ] Add `depends_on` for api
  - [ ] Define health check
  - [ ] Expose port 3000

- [ ] **Task 5: Create Environment File** (AC: 4)
  - [ ] Create `apps/.env.example` template
  - [ ] Add all required environment variables
  - [ ] Add comments explaining each variable
  - [ ] Document in README how to use

- [ ] **Task 6: Add Health Checks** (AC: 7)
  - [ ] PostgreSQL: `pg_isready` command
  - [ ] API: curl to `/health` endpoint
  - [ ] Frontend: curl to homepage

- [ ] **Task 7: Test Complete Stack** (AC: 5, 6, 8)
  - [ ] Run `docker-compose up --build`
  - [ ] Verify all services start
  - [ ] Test frontend → API connectivity
  - [ ] Test API → Database connectivity
  - [ ] Run `docker-compose down -v`
  - [ ] Verify clean removal

---

## Dev Notes

### Docker Compose Configuration

```yaml
# apps/docker-compose.yaml
version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    container_name: devops-postgres
    environment:
      POSTGRES_USER: ${DB_USER:-app_user}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-changeme}
      POSTGRES_DB: ${DB_NAME:-devops_demo}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./api/db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "5432:5432"
    networks:
      - devops-network
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${DB_USER:-app_user} -d ${DB_NAME:-devops_demo}",
        ]
      interval: 10s
      timeout: 5s
      retries: 5

  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    container_name: devops-api
    environment:
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: ${DB_NAME:-devops_demo}
      DB_USER: ${DB_USER:-app_user}
      DB_PASSWORD: ${DB_PASSWORD:-changeme}
      DEBUG: ${DEBUG:-false}
    ports:
      - "8000:8000"
    networks:
      - devops-network
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        NEXT_PUBLIC_API_URL: http://localhost:8000
    container_name: devops-frontend
    environment:
      NEXT_PUBLIC_API_URL: http://localhost:8000
    ports:
      - "3000:3000"
    networks:
      - devops-network
    depends_on:
      - api
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  devops-network:
    driver: bridge

volumes:
  postgres_data:
```

### Environment File Template

```bash
# apps/.env.example

# Database Configuration
DB_HOST=postgres
DB_PORT=5432
DB_NAME=devops_demo
DB_USER=app_user
DB_PASSWORD=changeme  # Change this in production!

# API Configuration
DEBUG=false

# Frontend Configuration
NEXT_PUBLIC_API_URL=http://localhost:8000
```

### Service Dependencies

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Frontend   │────▶│     API      │────▶│   PostgreSQL │
│   :3000      │     │    :8000     │     │    :5432     │
└──────────────┘     └──────────────┘     └──────────────┘
```

### Health Check Commands

| Service    | Health Check   | Interval |
| ---------- | -------------- | -------- |
| PostgreSQL | `pg_isready`   | 10s      |
| API        | `curl /health` | 30s      |
| Frontend   | `curl /`       | 30s      |

### Dependencies on Previous Stories

- **Story 1.3**: Database init.sql must exist
- **Story 1.5**: Dockerfiles must be created

### Key Commands

```bash
# Navigate to apps directory
cd apps

# Create .env from template
cp .env.example .env

# Start all services
docker-compose up --build

# Start in background
docker-compose up -d --build

# View logs
docker-compose logs -f

# Stop services
docker-compose down

# Stop and remove volumes
docker-compose down -v

# Rebuild specific service
docker-compose build api
```

---

## Testing

### Test Scenarios

1. **All services start** - `docker-compose up` completes without errors
2. **Health checks pass** - All services report healthy
3. **Frontend reaches API** - Homepage displays items from API
4. **API reaches database** - `/ready` endpoint returns 200
5. **Data persists** - Data survives container restart (not `down -v`)
6. **Clean removal** - `docker-compose down -v` removes all resources

### Test Commands

```bash
cd apps

# Start stack
docker-compose up -d --build

# Check service health
docker-compose ps

# Test API health
curl http://localhost:8000/health

# Test API readiness (DB connection)
curl http://localhost:8000/ready

# Test frontend
curl http://localhost:3000

# Create test item
curl -X POST http://localhost:8000/items \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Item"}'

# Verify item appears in frontend
curl http://localhost:3000

# Clean up
docker-compose down -v
```

---

## Change Log

| Date       | Version | Description         | Author |
| ---------- | ------- | ------------------- | ------ |
| 2025-01-26 | 1.0     | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
