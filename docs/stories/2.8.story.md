# Story 2.8: GitHub Actions - Deploy to Kubernetes (Dev)

## Status

**Draft**

---

## Story

**As a** DevOps engineer,
**I want** automated deployment to Kubernetes after successful build,
**so that** the dev environment always reflects the latest code.

---

## Acceptance Criteria

1. Deployment job runs after build/push succeeds
2. Workflow configures kubectl with Kind cluster (for local) or kubeconfig
3. Helm/Helmfile is used to deploy with new image tags
4. Deployment uses `values-dev.yaml` configuration
5. Deployment waits for rollout completion (`kubectl rollout status`)
6. Smoke test validates deployment (curl health endpoint)
7. Deployment job is skipped on PRs (only runs on main)
8. Deployment status is reported in workflow summary

---

## Tasks / Subtasks

- [ ] **Task 1: Add Deploy Job to CD Workflow** (AC: 1, 7)
  - [ ] Add `deploy-dev` job to `.github/workflows/cd.yaml`
  - [ ] Set `needs: [build-and-push]` to run after images are pushed
  - [ ] Only run on main: condition already met by cd.yaml trigger (push to main only)
  - [ ] Use `ubuntu-latest` runner

- [ ] **Task 2: Configure Kubectl and Helm** (AC: 2, 3)
  - [ ] Install kubectl: `azure/setup-kubectl@v3`
  - [ ] Install Helm: `azure/setup-helm@v3`
  - [ ] Install Helmfile: download binary from GitHub releases
  - [ ] Install Kind: `helm/kind-action@v1` or download binary
  - [ ] Create Kind cluster using `infra/kind/cluster-config.yaml`:
    ```bash
    kind create cluster --name devops-demo --config infra/kind/cluster-config.yaml
    ```
  - [ ] **Image Loading Strategy: Use imagePullSecrets** (mirrors production pattern)
    - Create ACR pull secret in the namespace:
      ```bash
      kubectl create namespace devops-demo --dry-run=client -o yaml | kubectl apply -f -
      kubectl create secret docker-registry acr-secret \
        --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
        --docker-username=${{ secrets.ACR_USERNAME }} \
        --docker-password=${{ secrets.ACR_PASSWORD }} \
        -n devops-demo
      ```
    - Helm charts must reference `imagePullSecrets: [name: acr-secret]`
  - [ ] Note: For AKS (future), use `azure/aks-set-context@v3` with Azure credentials

- [ ] **Task 3: Deploy with Helmfile** (AC: 3, 4)
  - [ ] Set image tags from build job outputs:
    ```yaml
    env:
      IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
    ```
    - Note: Story 2.7 must define this output in `build-and-push` job
  - [ ] Create namespace if not exists (already done in Task 2 for secret, but ensure idempotent):
    ```bash
    kubectl create namespace devops-demo --dry-run=client -o yaml | kubectl apply -f -
    ```
  - [ ] Run Helmfile with dev values:
    ```bash
    cd infra/helm
    helmfile -e dev sync --set api.image.tag=$IMAGE_TAG --set frontend.image.tag=$IMAGE_TAG
    ```

- [ ] **Task 4: Wait for Rollout** (AC: 5)
  - [ ] Wait for API deployment:
    ```bash
    kubectl rollout status deployment/api -n devops-demo --timeout=120s
    ```
  - [ ] Wait for Frontend deployment:
    ```bash
    kubectl rollout status deployment/frontend -n devops-demo --timeout=120s
    ```
  - [ ] Wait for PostgreSQL StatefulSet:
    ```bash
    kubectl rollout status statefulset/postgres -n devops-demo --timeout=120s
    ```

- [ ] **Task 5: Smoke Test** (AC: 6)
  - [ ] Port-forward API service with cleanup trap:
    ```bash
    # Start port-forward in background and capture PID
    kubectl port-forward svc/api 8000:8000 -n devops-demo &
    PF_PID=$!
    # Ensure cleanup on exit (success or failure)
    trap "kill $PF_PID 2>/dev/null || true" EXIT
    sleep 5
    ```
  - [ ] Curl health endpoint: `curl -f http://localhost:8000/health`
  - [ ] Curl readiness endpoint: `curl -f http://localhost:8000/ready`
  - [ ] Cleanup happens automatically via trap
  - [ ] Fail job if smoke tests fail (curl -f returns non-zero on HTTP errors)

- [ ] **Task 6: Report Deployment Status** (AC: 8)
  - [ ] Add step to write deployment summary:
    ```yaml
    - name: Deployment Summary
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Image Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: dev" >> $GITHUB_STEP_SUMMARY
        echo "- **Namespace**: devops-demo" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Check**: Passed ✅" >> $GITHUB_STEP_SUMMARY
    ```

- [ ] **Task 7: Test Full Pipeline** (AC: 1-8)
  - [ ] Push a code change to main
  - [ ] Verify CI → CD → Deploy pipeline runs end-to-end
  - [ ] Verify deployment completes and smoke tests pass
  - [ ] Verify deployment summary appears in workflow
  - [ ] Verify PRs do NOT trigger deployment

---

## Dev Notes

### Pipeline Architecture

[Source: architecture/14-deployment-architecture.md#14.3]

Full pipeline on merge to main:
1. **CI** (Story 2.6): Lint, test, build validation
2. **CD Build** (Story 2.7): Build Docker images, push to ACR with SHA tag
3. **CD Deploy** (THIS STORY): Deploy to dev environment using Helmfile
4. **Smoke tests**: Validate deployment health

### Kind Cluster in CI

For the dev deployment in CI, a Kind cluster is created within the GitHub Actions runner. This simulates a dev Kubernetes environment. Key considerations:

- Kind must be installed in the runner
- Cluster config from `infra/kind/cluster-config.yaml` (Story 1.7)
- **DECISION: Use imagePullSecrets** to pull from ACR (mirrors production pattern)

**Image Loading Strategy (CHOSEN: imagePullSecrets):**
```bash
# Create namespace and ACR pull secret
kubectl create namespace devops-demo --dry-run=client -o yaml | kubectl apply -f -
kubectl create secret docker-registry acr-secret \
  --docker-server=$ACR_LOGIN_SERVER \
  --docker-username=$ACR_USERNAME \
  --docker-password=$ACR_PASSWORD \
  -n devops-demo
```

This approach was chosen over `kind load docker-image` because:
1. Mirrors production deployment pattern (AKS will also use imagePullSecrets)
2. Tests the actual image pull flow from ACR
3. Validates ACR credentials work correctly
4. Helm charts can use consistent `imagePullSecrets` configuration across environments

### Helmfile Deploy Pattern

From Story 1.9:
- Helmfile: `infra/helm/helmfile.yaml`
- Dev values: `infra/helm/environments/values-dev.yaml`
- Charts: `infra/helm/charts/{api,frontend,postgres}/`
- Namespace: `devops-demo`

### Deployment Environment

[Source: architecture/14-deployment-architecture.md#14.2]

| Environment | Frontend URL | API URL | Purpose |
|-------------|-------------|---------|---------|
| Kind | `app.local` | `api.local` | Local K8s (used in CI) |

### Smoke Test Endpoints

[Source: architecture/5-api-specification.md]

| Endpoint | Expected Response | Purpose |
|----------|-------------------|---------|
| `/health` | `{"status": "healthy"}` 200 | Liveness check |
| `/ready` | 200 | Readiness check (DB connected) |

### Key Constraints

- **Kind in CI** — the GitHub Actions runner has Docker, so Kind can run there
- **Image loading** — Kind can't pull from ACR directly; images must be loaded or pull secrets configured
- **Port-forward in CI** — works but needs `&` to background the process and `sleep` for startup
- **Deployment only on main** (AC7) — cd.yaml already restricts to main branch
- **Rollout timeout** — 120s should be sufficient; increase if DB init takes longer
- **PostgreSQL needs persistent data** — but in CI, data is ephemeral (acceptable)
- **`$GITHUB_STEP_SUMMARY`** — GitHub-provided file for writing job summaries in Markdown

### Dependencies on Previous Stories

- **Story 1.7**: Kind cluster config (`infra/kind/cluster-config.yaml`)
- **Story 1.9**: Helmfile and Helm charts (must have `dev` environment defined)
- **Story 2.6**: CI workflow (must pass first)
- **Story 2.7**: Build & push job — **MUST expose output `image-tag`** in job outputs:
  ```yaml
  # In Story 2.7's build-and-push job:
  outputs:
    image-tag: ${{ steps.meta.outputs.tags }}  # or similar
  ```

---

## Testing

### Testing Requirements

| Test Type | Coverage | Method |
|-----------|----------|--------|
| E2E | Full pipeline | Push to main → observe deploy |
| E2E | Smoke tests | curl health/ready endpoints |
| E2E | Deployment summary | GitHub workflow UI |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **Deploy job runs after build** — `needs: build-and-push` enforced
2. **Kind cluster created** — `kubectl get nodes` shows Ready in CI
3. **Helmfile deploys** — `helmfile -e dev sync` succeeds
4. **Rollout completes** — All deployments/statefulsets reach Ready
5. **Health check passes** — `curl /health` returns 200
6. **Readiness passes** — `curl /ready` returns 200
7. **Summary written** — Workflow summary shows deployment details
8. **PR does not deploy** — PRs skip the deploy job

### Test Commands

```bash
# Trigger full pipeline
git push origin main

# Check workflow
gh run list --workflow=cd.yaml
gh run view <run-id>

# View deployment summary in GitHub Actions UI
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-27 | 1.0 | Initial story draft | SM Bob |
| 2026-01-28 | 1.1 | Fixed: Chose imagePullSecrets strategy, added namespace creation, added port-forward cleanup trap, clarified Story 2.7 output dependency | PO Sarah |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
