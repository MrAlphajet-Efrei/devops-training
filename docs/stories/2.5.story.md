# Story 2.5: Terraform Modules Refactoring

## Status

**Draft**

---

## Story

**As a** DevOps engineer,
**I want** Terraform code organized into reusable modules,
**so that** the infrastructure code is maintainable and follows best practices.

---

## Acceptance Criteria

1. Module structure exists: `infra/terraform/modules/`
2. ACR module encapsulates container registry creation
3. Key Vault module encapsulates key vault creation
4. Storage module encapsulates storage account (for state bootstrap)
5. Root module in `infra/terraform/` calls child modules
6. Variables are properly typed with descriptions
7. Outputs are defined for each module
8. `terraform validate` passes
9. `terraform fmt -check` passes (code is formatted)
10. README documents module usage

---

## Tasks / Subtasks

- [ ] **Task 1: Create Module Directory Structure** (AC: 1)
  - [ ] Create `infra/terraform/modules/acr/`
  - [ ] Create `infra/terraform/modules/keyvault/`
  - [ ] Create `infra/terraform/modules/storage/`
  - [ ] Each module directory gets: `main.tf`, `variables.tf`, `outputs.tf`

- [ ] **Task 2: Create ACR Module** (AC: 2, 6, 7)
  - [ ] Move ACR resource from `infra/terraform/acr.tf` into `modules/acr/main.tf`
  - [ ] Define `modules/acr/variables.tf`:
    - `name` (string, required): ACR name
    - `resource_group_name` (string, required): Resource group
    - `location` (string, required): Azure region
    - `sku` (string, default: "Basic"): ACR SKU
    - `admin_enabled` (bool, default: true): Enable admin user
  - [ ] Define `modules/acr/outputs.tf`:
    - `id`: ACR resource ID
    - `login_server`: ACR login server URL
    - `admin_username`: Admin username
    - `admin_password`: Admin password (sensitive)
  - [ ] All variables must have `type` and `description`
  - [ ] Add validation blocks where appropriate (e.g., name length/pattern)

- [ ] **Task 3: Create Key Vault Module** (AC: 3, 6, 7)
  - [ ] Move Key Vault resource from `infra/terraform/keyvault.tf` into `modules/keyvault/main.tf`
  - [ ] Define `modules/keyvault/variables.tf`:
    - `name` (string, required): Key Vault name
    - `resource_group_name` (string, required): Resource group
    - `location` (string, required): Azure region
    - `tenant_id` (string, required): Azure AD tenant ID
    - `object_id` (string, required): SP object ID for access policy
    - `sku_name` (string, default: "standard"): SKU
    - `soft_delete_retention_days` (number, default: 7): Retention days
    - `purge_protection_enabled` (bool, default: false): Purge protection
  - [ ] Define `modules/keyvault/outputs.tf`:
    - `id`: Key Vault resource ID
    - `uri`: Key Vault URI
    - `name`: Key Vault name

- [ ] **Task 4: Create Storage Module** (AC: 4, 6, 7)
  - [ ] Create `modules/storage/main.tf` with `azurerm_storage_account` resource
  - [ ] This module documents the storage account pattern even though the state backend storage was created manually via bootstrap
  - [ ] Define `modules/storage/variables.tf`:
    - `name` (string, required): Storage account name
    - `resource_group_name` (string, required): Resource group
    - `location` (string, required): Azure region
    - `account_tier` (string, default: "Standard"): Account tier
    - `account_replication_type` (string, default: "LRS"): Replication type
  - [ ] Define `modules/storage/outputs.tf`:
    - `id`: Storage account ID
    - `name`: Storage account name
    - `primary_access_key`: Access key (sensitive)
    - `primary_blob_endpoint`: Blob endpoint URL

- [ ] **Task 5: Update Root Module to Call Child Modules** (AC: 5)
  - [ ] Replace inline resources in `infra/terraform/main.tf` with module calls:
    ```hcl
    module "acr" {
      source              = "./modules/acr"
      name                = var.acr_name
      resource_group_name = var.resource_group_name
      location            = var.location
    }

    module "keyvault" {
      source              = "./modules/keyvault"
      name                = var.keyvault_name
      resource_group_name = var.resource_group_name
      location            = var.location
      tenant_id           = data.azurerm_client_config.current.tenant_id
      object_id           = data.azurerm_client_config.current.object_id
    }
    ```
  - [ ] Remove old inline files (`acr.tf`, `keyvault.tf`) — resources now live in modules
  - [ ] Update `outputs.tf` to reference module outputs (e.g., `module.acr.login_server`)
  - [ ] Ensure `data "azurerm_client_config" "current" {}` remains in root module

- [ ] **Task 6: Run Terraform State Migration** (AC: 5, 8)
  - [ ] Run `terraform init` to detect module changes
  - [ ] Use `terraform state mv` to migrate existing resources to module paths:
    - `terraform state mv azurerm_container_registry.acr module.acr.azurerm_container_registry.this`
    - `terraform state mv azurerm_key_vault.kv module.keyvault.azurerm_key_vault.this`
  - [ ] Run `terraform plan` — should show **no changes** (resources moved, not recreated)
  - [ ] If plan shows destroy/create, fix the state move commands

- [ ] **Task 7: Format and Validate** (AC: 8, 9)
  - [ ] Run `terraform fmt -recursive` on all files in `infra/terraform/`
  - [ ] Run `terraform fmt -check -recursive` to verify formatting
  - [ ] Run `terraform validate` to verify configuration
  - [ ] Fix any validation errors

- [ ] **Task 8: Create Environment Directories** (AC: 1)
  - [ ] Create `infra/terraform/environments/dev/` with `terraform.tfvars`
  - [ ] Create `infra/terraform/environments/prod/` with `terraform.tfvars`
  - [ ] Dev values: Basic SKU, dev naming, purge protection off
  - [ ] Prod values: Standard SKU, prod naming, purge protection on
  - [ ] Create `terraform.tfvars.example` as template

- [ ] **Task 9: Document Modules** (AC: 10)
  - [ ] Update `infra/terraform/README.md` with:
    - Module structure diagram
    - Each module's purpose, inputs, and outputs
    - How to use modules (root module example)
    - How to use environment-specific tfvars
    - State migration notes (for this refactoring)
    - `terraform fmt` and `terraform validate` instructions

---

## Dev Notes

### Module Directory Structure

[Source: architecture/12-unified-project-structure.md]

```
infra/terraform/
├── environments/
│   ├── dev/
│   │   └── terraform.tfvars
│   └── prod/
│       └── terraform.tfvars
├── modules/
│   ├── acr/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   ├── keyvault/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   └── outputs.tf
│   └── storage/
│       ├── main.tf
│       ├── variables.tf
│       └── outputs.tf
├── backend.tf
├── providers.tf
├── variables.tf
├── outputs.tf
├── main.tf
└── README.md
```

### Terraform Module Best Practices

- Each module should have `main.tf`, `variables.tf`, `outputs.tf`
- All variables must have `type` and `description`
- Use `validation` blocks for input validation
- Mark sensitive outputs with `sensitive = true`
- Use `this` as resource name inside modules (convention: `azurerm_container_registry.this`)
- Module sources use relative paths: `source = "./modules/acr"`

### State Migration Pattern

When refactoring inline resources into modules, Terraform sees the old resource path deleted and the new module path created — it wants to destroy and recreate. To avoid this:

```bash
# Move state entries to new module paths
terraform state mv azurerm_container_registry.acr module.acr.azurerm_container_registry.this
terraform state mv azurerm_key_vault.kv module.keyvault.azurerm_key_vault.this

# Verify no changes
terraform plan  # Should show: No changes
```

**CRITICAL**: Run state mv BEFORE terraform plan/apply to prevent resource destruction.

### Environment-Specific Variables Pattern

```hcl
# environments/dev/terraform.tfvars
acr_name            = "acrdevopsdemodev"
keyvault_name       = "kv-devops-demo-dev"
location            = "eastus"
resource_group_name = "rg-devops-demo"

# environments/prod/terraform.tfvars
acr_name            = "acrdevopsdemoprod"
keyvault_name       = "kv-devops-demo-prod"
location            = "eastus"
resource_group_name = "rg-devops-demo-prod"
```

Usage: `terraform plan -var-file=environments/dev/terraform.tfvars`

### Tech Stack Versions

[Source: architecture/3-tech-stack.md]

| Tool | Version | Purpose |
|------|---------|---------|
| Terraform | 1.5+ | Infrastructure provisioning |

### Key Constraints

- **State migration is critical** — incorrect migration destroys and recreates resources
- **Storage module is for documentation** — the actual state backend storage was bootstrapped manually
- **Architecture shows `aks/` module** — that will come in Epic 4, not this story
- **`terraform fmt`** uses canonical formatting — tab-based alignment
- **Variables must be typed** — no untyped variables allowed

### Dependencies on Previous Stories

- **Story 2.3**: ACR resource exists in Terraform state
- **Story 2.4**: Key Vault resource exists in Terraform state

---

## Testing

### Testing Requirements

| Test Type | Coverage | Method |
|-----------|----------|--------|
| E2E | Module structure | Directory verification |
| E2E | State migration | terraform plan (no changes) |
| E2E | Formatting | terraform fmt -check |
| E2E | Validation | terraform validate |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **Module directories exist** — `ls infra/terraform/modules/` shows acr, keyvault, storage
2. **State migration clean** — `terraform plan` shows no changes after migration
3. **Formatting passes** — `terraform fmt -check -recursive` exits 0
4. **Validation passes** — `terraform validate` exits 0
5. **Outputs still work** — `terraform output acr_login_server` returns same value
6. **Existing resources untouched** — ACR and Key Vault still exist in Azure
7. **Environment tfvars work** — `terraform plan -var-file=environments/dev/terraform.tfvars` succeeds

### Test Commands

```bash
cd infra/terraform

# Verify module structure
ls modules/acr/ modules/keyvault/ modules/storage/

# Initialize with modules
terraform init

# State migration
terraform state mv azurerm_container_registry.acr module.acr.azurerm_container_registry.this
terraform state mv azurerm_key_vault.kv module.keyvault.azurerm_key_vault.this

# Verify no changes
terraform plan  # Must show: No changes

# Format check
terraform fmt -check -recursive

# Validate
terraform validate

# Verify outputs
terraform output acr_login_server
terraform output keyvault_uri

# Verify Azure resources still exist
az acr show --name <acr-name> -o table
az keyvault show --name <kv-name> -o table
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-27 | 1.0 | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
