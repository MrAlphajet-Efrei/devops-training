# Story 1.9: Basic Helm Charts

## Status

**Approved**

---

## Story

**As a** DevOps engineer,
**I want** the application packaged as Helm charts,
**so that** I can manage deployments declaratively with customizable values.

---

## Acceptance Criteria

1. Helm chart exists for API (`infra/helm/charts/api/`)
2. Helm chart exists for Frontend (`infra/helm/charts/frontend/`)
3. Helm chart exists for PostgreSQL (`infra/helm/charts/postgres/`) — custom chart for learning (not Bitnami subchart)
4. Each chart has `values.yaml` with configurable parameters (image, replicas, resources)
5. `values-dev.yaml` and `values-prod.yaml` demonstrate environment-specific config
6. Charts pass `helm lint` validation
7. Charts can be installed with `helm install` command
8. Charts include NOTES.txt with post-install instructions
9. Helmfile.yaml orchestrates all charts together
10. `helmfile sync` deploys the complete stack to Kind

---

## Tasks / Subtasks

- [ ] **Task 1: Create API Helm Chart** (AC: 1, 4, 6, 7, 8)
  - [ ] Run `helm create infra/helm/charts/api` to scaffold chart
  - [ ] Clean up generated templates (remove unused boilerplate)
  - [ ] Edit `Chart.yaml`: name=api, version=0.1.0, appVersion=0.1.0, description
  - [ ] Edit `values.yaml` with configurable parameters:
    - `image.repository: devops-api`
    - `image.tag: "0.1.0"`
    - `image.pullPolicy: Never` (for Kind)
    - `replicaCount: 1`
    - `service.type: ClusterIP`
    - `service.port: 8000`
    - `resources.requests: { memory: "128Mi", cpu: "100m" }`
    - `resources.limits: { memory: "256Mi", cpu: "500m" }`
    - `env` section for DB_HOST, DB_PORT, DB_NAME, DEBUG
    - `secrets` section referencing db-secret
    - `probes.liveness` and `probes.readiness` configuration
  - [ ] Edit `templates/deployment.yaml`: use values for image, resources, probes, env, securityContext
  - [ ] Edit `templates/service.yaml`: ClusterIP on port 8000
  - [ ] Create `templates/configmap.yaml`: API non-sensitive config
  - [ ] Edit `templates/NOTES.txt`: post-install instructions with port-forward command
  - [ ] Verify: `helm lint infra/helm/charts/api`

- [ ] **Task 2: Create Frontend Helm Chart** (AC: 2, 4, 6, 7, 8)
  - [ ] Run `helm create infra/helm/charts/frontend` to scaffold chart
  - [ ] Clean up generated templates
  - [ ] Edit `Chart.yaml`: name=frontend, version=0.1.0, appVersion=0.1.0
  - [ ] Edit `values.yaml`:
    - `image.repository: devops-frontend`
    - `image.tag: "0.1.0"`
    - `image.pullPolicy: Never`
    - `replicaCount: 1`
    - `service.type: ClusterIP`
    - `service.port: 3000`
    - `resources.requests: { memory: "64Mi", cpu: "50m" }`
    - `resources.limits: { memory: "128Mi", cpu: "200m" }`
    - `env.NEXT_PUBLIC_API_URL: http://api:8000`
  - [ ] Edit `templates/deployment.yaml`: use values for image, resources, env
  - [ ] Edit `templates/service.yaml`: ClusterIP on port 3000
  - [ ] Create `templates/configmap.yaml`: Frontend config
  - [ ] Edit `templates/NOTES.txt`: port-forward instructions
  - [ ] Verify: `helm lint infra/helm/charts/frontend`

- [ ] **Task 3: Create PostgreSQL Helm Chart** (AC: 3, 4, 6, 7, 8)
  - [ ] Create `infra/helm/charts/postgres/` directory manually (don't scaffold — simpler chart)
  - [ ] Create `Chart.yaml`: name=postgres, version=0.1.0
  - [ ] Create `values.yaml`:
    - `image.repository: postgres`
    - `image.tag: "15-alpine"`
    - `image.pullPolicy: IfNotPresent`
    - `storage.size: 1Gi`
    - `resources.requests: { memory: "128Mi", cpu: "100m" }`
    - `resources.limits: { memory: "256Mi", cpu: "500m" }`
    - `auth.username: app_user`
    - `auth.password: changeme`
    - `auth.database: devops_demo`
  - [ ] Create `templates/secret.yaml`: DB credentials (base64 from values)
  - [ ] Create `templates/statefulset.yaml`: PostgreSQL StatefulSet with PVC
  - [ ] Create `templates/service.yaml`: ClusterIP on port 5432, name=postgres
  - [ ] Create `templates/configmap.yaml`: init.sql content for DB initialization
  - [ ] Mount init.sql ConfigMap at `/docker-entrypoint-initdb.d/` in the StatefulSet template
  - [ ] Create `templates/_helpers.tpl` with standard label and fullname helpers (not scaffolded — manual chart)
  - [ ] Create `templates/NOTES.txt`: connection info and port-forward command
  - [ ] Verify: `helm lint infra/helm/charts/postgres`

- [ ] **Task 4: Create Environment-Specific Values** (AC: 5)
  - [ ] Create `infra/helm/environments/values-dev.yaml`:
    - API: 1 replica, `imagePullPolicy: Never`, debug=true, lower resources
    - Frontend: 1 replica, `imagePullPolicy: Never`
    - PostgreSQL: 1Gi storage, dev credentials
  - [ ] Create `infra/helm/environments/values-prod.yaml`:
    - API: 2 replicas, `imagePullPolicy: Always`, debug=false, higher resources
    - Frontend: 2 replicas, `imagePullPolicy: Always`
    - PostgreSQL: 5Gi storage, placeholder for real credentials
    - Comment: "Production values — update secrets before deploying"

- [ ] **Task 5: Create Helmfile** (AC: 9, 10)
  - [ ] Create `infra/helm/helmfile.yaml`
  - [ ] Define repositories (none needed for local charts)
  - [ ] Define releases:
    - `postgres`: chart=./charts/postgres, namespace=devops-demo, values from environments
    - `api`: chart=./charts/api, namespace=devops-demo, needs=[postgres], values from environments
    - `frontend`: chart=./charts/frontend, namespace=devops-demo, needs=[api], values from environments
  - [ ] Configure environment selector (dev/prod) via `environments:` block
  - [ ] Verify: `helmfile lint`

- [ ] **Task 6: Add Makefile Targets** (AC: 7, 10)
  - [ ] Add `helm-lint` target: lint all charts
  - [ ] Add `helm-deploy` target: `helmfile -e dev sync` (from infra/helm/)
  - [ ] Add `helm-delete` target: `helmfile destroy` (from infra/helm/)
  - [ ] Add `helm-status` target: `helm list -n devops-demo`
  - [ ] Add `helm-diff` target: `helmfile -e dev diff` (shows changes before apply)

- [ ] **Task 7: Test Helm Deployment** (AC: 6, 7, 10)
  - [ ] Ensure Kind cluster is running with images loaded
  - [ ] Run `helm lint` on all charts
  - [ ] Run `helmfile -e dev sync` from `infra/helm/`
  - [ ] Verify all pods running in `devops-demo` namespace
  - [ ] Port-forward and test API health + readiness
  - [ ] Port-forward and test Frontend serves page
  - [ ] Run `helmfile destroy` and verify clean removal
  - [ ] Test individual chart install: `helm install api infra/helm/charts/api -n devops-demo`

---

## Dev Notes

### Helm Chart Directory Structure

[Source: architecture/12-unified-project-structure.md]

```
infra/helm/
├── charts/
│   ├── api/
│   │   ├── Chart.yaml
│   │   ├── values.yaml
│   │   └── templates/
│   │       ├── deployment.yaml
│   │       ├── service.yaml
│   │       ├── configmap.yaml
│   │       ├── _helpers.tpl
│   │       └── NOTES.txt
│   ├── frontend/
│   │   ├── Chart.yaml
│   │   ├── values.yaml
│   │   └── templates/
│   │       ├── deployment.yaml
│   │       ├── service.yaml
│   │       ├── configmap.yaml
│   │       ├── _helpers.tpl
│   │       └── NOTES.txt
│   └── postgres/
│       ├── Chart.yaml
│       ├── values.yaml
│       └── templates/
│           ├── statefulset.yaml
│           ├── service.yaml
│           ├── secret.yaml
│           ├── configmap.yaml
│           ├── _helpers.tpl
│           └── NOTES.txt
├── environments/
│   ├── values-dev.yaml
│   └── values-prod.yaml
└── helmfile.yaml
```

### Tech Stack Versions

[Source: architecture/3-tech-stack.md]

| Tool     | Version | Purpose                   |
| -------- | ------- | ------------------------- |
| Helm     | 3.x     | K8s app packaging         |
| Helmfile | 0.158+  | Multi-chart orchestration |

### Resource Limits Reference

[Source: architecture/15-security-and-performance.md#15.3]

| Service    | Request Memory | Request CPU | Limit Memory | Limit CPU |
| ---------- | -------------- | ----------- | ------------ | --------- |
| API        | 128Mi          | 100m        | 256Mi        | 500m      |
| Frontend   | 64Mi           | 50m         | 128Mi        | 200m      |
| PostgreSQL | 128Mi          | 100m        | 256Mi        | 500m      |

### Health Probes (API Chart)

[Source: architecture/5-api-specification.md]

```yaml
# In values.yaml
probes:
  liveness:
    path: /health
    port: 8000
    initialDelaySeconds: 10
    periodSeconds: 30
  readiness:
    path: /ready
    port: 8000
    initialDelaySeconds: 5
    periodSeconds: 10
```

### Helmfile Structure Reference

```yaml
# infra/helm/helmfile.yaml
environments:
  dev:
    values:
      - environments/values-dev.yaml
  prod:
    values:
      - environments/values-prod.yaml

releases:
  - name: postgres
    namespace: devops-demo
    chart: ./charts/postgres
    values:
      - "{{ .Values | toYaml }}"

  - name: api
    namespace: devops-demo
    chart: ./charts/api
    needs:
      - postgres
    values:
      - "{{ .Values | toYaml }}"

  - name: frontend
    namespace: devops-demo
    chart: ./charts/frontend
    needs:
      - api
    values:
      - "{{ .Values | toYaml }}"
```

**Note**: The `{{ .Values | toYaml }}` global passthrough syntax depends on Helmfile version and may not work as expected. A more reliable alternative is to use per-release values files directly:

```yaml
releases:
  - name: postgres
    namespace: devops-demo
    chart: ./charts/postgres
    values:
      - environments/values-dev.yaml # contains postgres: key
  - name: api
    namespace: devops-demo
    chart: ./charts/api
    needs:
      - postgres
    values:
      - environments/values-dev.yaml # contains api: key
  - name: frontend
    namespace: devops-demo
    chart: ./charts/frontend
    needs:
      - api
    values:
      - environments/values-dev.yaml # contains frontend: key
```

The `needs` field ensures deployment ordering (postgres → api → frontend). Each chart reads its own top-level key from the shared values file. Consult `helmfile` docs for the exact syntax matching your installed version.

### Environment-Specific Values Pattern

**Dev values** — minimal resources, single replica, local images:

```yaml
# infra/helm/environments/values-dev.yaml
api:
  replicaCount: 1
  image:
    pullPolicy: Never
  env:
    DEBUG: "true"

frontend:
  replicaCount: 1
  image:
    pullPolicy: Never

postgres:
  storage:
    size: 1Gi
```

**Prod values** — higher resources, multiple replicas, registry images:

```yaml
# infra/helm/environments/values-prod.yaml
api:
  replicaCount: 2
  image:
    pullPolicy: Always
  env:
    DEBUG: "false"
  resources:
    requests: { memory: "256Mi", cpu: "200m" }
    limits: { memory: "512Mi", cpu: "1000m" }

frontend:
  replicaCount: 2
  image:
    pullPolicy: Always

postgres:
  storage:
    size: 5Gi
```

### Helm Template Best Practices

- Use `_helpers.tpl` for reusable template snippets (labels, selectors, fullname)
- Use `{{ include "chart.fullname" . }}` for resource naming consistency
- Use `{{ .Values.x | default "fallback" }}` for safe defaults
- Quote all values in templates: `{{ .Values.image.tag | quote }}`
- Use `with` blocks for optional sections (e.g., `{{ with .Values.nodeSelector }}`)
- In `secret.yaml` templates, use `{{ .Values.auth.password | b64enc }}` to base64-encode values from `values.yaml` (Helm provides the `b64enc` function natively)

### PostgreSQL Chart Decision: Custom vs Bitnami

AC3 allows using Bitnami subchart. For this learning project, **create a custom chart** to understand Helm templating deeply. Bitnami charts are complex and hide the learning. The custom chart reuses the same StatefulSet pattern from Story 1.8 but templatized.

### Previous Story Insights

From Story 1.8 (Kubernetes Manifests):

- Raw manifests in `infra/k8s/base/` serve as the reference implementation
- The Helm charts should produce equivalent resources when rendered
- Namespace: `devops-demo`
- Service names: `api`, `frontend`, `postgres`
- `imagePullPolicy: Never` for local Kind deployment

From Story 1.7 (Kind Cluster):

- Cluster name: `devops-demo`
- NGINX Ingress installed (Ingress resources can be added to charts later)

From Story 1.5 (Docker):

- Image tags: `devops-api:0.1.0`, `devops-frontend:0.1.0`
- PostgreSQL: `postgres:15-alpine`

### Key Constraints

- **Custom PostgreSQL chart** — don't use Bitnami (learning purpose)
- **Helmfile required** — AC9 and AC10 specifically require Helmfile orchestration
- **NOTES.txt required** — AC8 specifies post-install instructions in each chart
- **Two environment files** — AC5 requires both dev and prod value files
- **`helm lint` must pass** — AC6, run on each chart individually
- **Namespace consistency** — all releases deploy to `devops-demo`
- **Chart names vs release names** — chart directory name should match the release name in helmfile
- **Delete raw manifests?** — No. Keep `infra/k8s/base/` as a reference. Helm charts are the preferred deployment method going forward.

### Dependencies on Previous Stories

- **Story 1.7**: Kind cluster must exist
- **Story 1.8**: Raw K8s manifests provide the reference for what Helm charts should produce

---

## Testing

### Testing Requirements

| Test Type | Coverage      | Method                             |
| --------- | ------------- | ---------------------------------- |
| Lint      | All charts    | `helm lint` per chart              |
| E2E       | Full stack    | `helmfile sync` + curl smoke tests |
| E2E       | Individual    | `helm install` per chart           |
| E2E       | Clean removal | `helmfile destroy`                 |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **API chart lints** — `helm lint infra/helm/charts/api` passes
2. **Frontend chart lints** — `helm lint infra/helm/charts/frontend` passes
3. **PostgreSQL chart lints** — `helm lint infra/helm/charts/postgres` passes
4. **Helmfile lints** — `helmfile lint` passes
5. **Helmfile deploys (dev)** — `helmfile -e dev sync` succeeds
6. **All pods running** — `kubectl get pods -n devops-demo` shows all Running/Ready
7. **API health check** — port-forward + `curl localhost:8000/health` returns healthy
8. **API readiness** — `curl localhost:8000/ready` returns 200
9. **Frontend serves** — port-forward + `curl localhost:3000` returns HTML
10. **NOTES.txt displayed** — `helm install` shows post-install notes
11. **Individual install works** — `helm install api charts/api -n devops-demo` succeeds
12. **Helmfile destroy** — `helmfile destroy` removes all releases cleanly
13. **Values override works** — dev vs prod values produce different resource limits

### Test Commands

```bash
# Prerequisite: Kind cluster running, images loaded
make kind-create
make k8s-load-images

# Lint all charts
make helm-lint
# OR:
helm lint infra/helm/charts/api
helm lint infra/helm/charts/frontend
helm lint infra/helm/charts/postgres

# Deploy with Helmfile
cd infra/helm
helmfile -e dev sync

# Check status
helm list -n devops-demo
kubectl get all -n devops-demo

# Port-forward and test
kubectl port-forward svc/api 8000:8000 -n devops-demo &
kubectl port-forward svc/frontend 3000:3000 -n devops-demo &
curl http://localhost:8000/health
curl http://localhost:8000/ready
curl http://localhost:3000

# Verify environment-specific values
helm get values api -n devops-demo

# Template render check (no install)
helm template api infra/helm/charts/api -f infra/helm/environments/values-dev.yaml

# Clean up
helmfile destroy
```

---

## Change Log

| Date       | Version | Description         | Author |
| ---------- | ------- | ------------------- | ------ |
| 2026-01-27 | 1.0     | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
