# Story 2.4: Terraform Azure Resources - Key Vault

## Status

**Approved**

---

## Story

**As a** DevOps engineer,
**I want** Azure Key Vault provisioned via Terraform,
**so that** I have secure storage for secrets (to be used later in Epic 4).

---

## Acceptance Criteria

1. Key Vault resource is defined in Terraform (`azurerm_key_vault`)
2. Access policies grant Service Principal appropriate permissions
3. Soft delete and purge protection are configured appropriately
4. Key Vault name is globally unique
5. `terraform apply` successfully creates Key Vault
6. Manual test: secret can be set/retrieved via Azure CLI
7. Output values expose Key Vault URI

---

## Tasks / Subtasks

- [ ] **Task 1: Create Key Vault Terraform Configuration** (AC: 1, 3, 4)
  - [ ] Create `infra/terraform/keyvault.tf` (inline first — will be modularized in Story 2.5)
  - [ ] Define `azurerm_key_vault` resource:
    - Name: globally unique, 3-24 chars, alphanumeric and hyphens (e.g., `kv-devops-demo-<unique>`)
    - Resource group: `rg-devops-demo`
    - Location: same as resource group
    - SKU: `standard`
    - Tenant ID: from `data.azurerm_client_config.current.tenant_id`
    - Soft delete retention: 7 days (minimum, keeps costs low for learning)
    - Purge protection: `false` (for learning — allows full cleanup; set `true` in production)
  - [ ] Add `data "azurerm_client_config" "current" {}` to get current tenant/object ID

- [ ] **Task 2: Configure Access Policies** (AC: 2)
  - [ ] Define access policy for the Service Principal (current client):
    - `tenant_id`: from data source
    - `object_id`: from data source (`data.azurerm_client_config.current.object_id`)
    - `secret_permissions`: `["Get", "List", "Set", "Delete", "Purge"]`
  - [ ] This grants the SP used by Terraform and GitHub Actions access to secrets
  - [ ] Note: In production, use RBAC instead of access policies

- [ ] **Task 3: Add Variables** (AC: 4)
  - [ ] Add `keyvault_name` variable to `variables.tf`
  - [ ] Add validation: 3-24 chars, alphanumeric and hyphens
  - [ ] Add description documenting naming constraints

- [ ] **Task 4: Define Outputs** (AC: 7)
  - [ ] Add to `outputs.tf`:
    - `keyvault_uri` — the Key Vault URI
    - `keyvault_id` — the resource ID (useful for later stories)
    - `keyvault_name` — the Key Vault name

- [ ] **Task 5: Plan and Apply** (AC: 5)
  - [ ] Run `terraform plan` — verify Key Vault resource appears
  - [ ] Run `terraform apply` — confirm resource creation
  - [ ] Verify: `az keyvault show --name <kv-name> -o table`

- [ ] **Task 6: Manual Secret Test** (AC: 6)
  - [ ] Set a test secret: `az keyvault secret set --vault-name <kv-name> --name test-secret --value "hello-world"`
  - [ ] Retrieve it: `az keyvault secret show --vault-name <kv-name> --name test-secret --query value -o tsv`
  - [ ] Delete test secret: `az keyvault secret delete --vault-name <kv-name> --name test-secret`
  - [ ] Purge test secret: `az keyvault secret purge --vault-name <kv-name> --name test-secret`

- [ ] **Task 7: Document** (AC: 1-7)
  - [ ] Update `infra/terraform/README.md` with Key Vault section
  - [ ] Document naming constraints
  - [ ] Document access policy configuration
  - [ ] Document how to set/get secrets via CLI
  - [ ] Document that Key Vault will be integrated with K8s CSI Driver in Epic 4

---

## Dev Notes

### Key Vault Terraform Resource Reference

```hcl
data "azurerm_client_config" "current" {}

resource "azurerm_key_vault" "kv" {
  name                       = var.keyvault_name
  location                   = var.location
  resource_group_name        = var.resource_group_name
  tenant_id                  = data.azurerm_client_config.current.tenant_id
  sku_name                   = "standard"
  soft_delete_retention_days = 7
  purge_protection_enabled   = false

  access_policy {
    tenant_id = data.azurerm_client_config.current.tenant_id
    object_id = data.azurerm_client_config.current.object_id

    secret_permissions = [
      "Get", "List", "Set", "Delete", "Purge"
    ]
  }
}
```

### Secrets Architecture

[Source: architecture/15-security-and-performance.md#15.1]

- **Phase 1** (current): Kubernetes Secrets (base64 encoded) — already in use from Story 1.8
- **Phase 2** (Epic 4): Azure Key Vault + CSI Driver — this story provisions the Key Vault infrastructure

The Key Vault created here will be integrated with Kubernetes via the CSI Secret Store Driver in Epic 4.

### Key Vault Naming Rules

- 3-24 characters
- Alphanumeric and hyphens only
- Must start with a letter
- Must be globally unique
- Naming convention: `kv-devops-demo-<suffix>` (e.g., `kv-devops-demo-001`)

### Tech Stack Versions

[Source: architecture/3-tech-stack.md]

| Tool | Version | Purpose |
|------|---------|---------|
| Terraform | 1.5+ | Infrastructure provisioning |
| Azure Key Vault + CSI Driver | - | Enterprise secrets (Phase 2) |

### Key Constraints

- **Soft delete** is mandatory on Key Vault (cannot be disabled). Minimum retention is 7 days.
- **Purge protection disabled** for learning — allows complete cleanup. In production, enable it.
- **Access policies vs RBAC**: This story uses access policies for simplicity. Production should use Azure RBAC.
- **This is inline Terraform** — will be refactored into a module in Story 2.5
- **Cost**: Key Vault standard SKU charges per operation (~$0.03/10,000 operations). Free tier covers learning usage.

### Dependencies on Previous Stories

- **Story 2.1**: Azure account, Service Principal, Resource Group
- **Story 2.2**: Terraform backend configured
- **Story 2.3**: Can be done in parallel (no dependency between ACR and Key Vault)

---

## Testing

### Testing Requirements

| Test Type | Coverage | Method |
|-----------|----------|--------|
| E2E | Terraform plan/apply | CLI execution |
| E2E | Key Vault creation | az keyvault show |
| E2E | Secret operations | az keyvault secret set/show |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **Terraform plan shows Key Vault** — `terraform plan` shows resource to add
2. **Terraform apply succeeds** — Key Vault is created
3. **Key Vault exists** — `az keyvault show --name <name>` returns details
4. **Secret set works** — `az keyvault secret set` succeeds
5. **Secret get works** — `az keyvault secret show` returns correct value
6. **Outputs correct** — `terraform output keyvault_uri` returns valid URI

### Test Commands

```bash
cd infra/terraform

# Plan and apply
terraform plan
terraform apply

# Verify Key Vault
az keyvault show --name <kv-name> -o table

# Test secret operations
az keyvault secret set --vault-name <kv-name> --name test-secret --value "hello"
az keyvault secret show --vault-name <kv-name> --name test-secret --query value -o tsv

# Verify outputs
terraform output keyvault_uri

# Cleanup test secret
az keyvault secret delete --vault-name <kv-name> --name test-secret
az keyvault secret purge --vault-name <kv-name> --name test-secret
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-27 | 1.0 | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
