# Story 2.6: GitHub Actions - Build & Test Workflow

## Status

**Approved**

---

## Story

**As a** DevOps engineer,
**I want** a GitHub Actions workflow that builds and tests on every push,
**so that** I get fast feedback on code quality.

---

## Acceptance Criteria

1. Workflow file exists at `.github/workflows/ci.yaml`
2. Workflow triggers on push to `main` and on pull requests
3. API job: installs dependencies, runs linter, runs pytest
4. Frontend job: installs dependencies, runs linter, runs build
5. Jobs run in parallel for efficiency
6. Workflow uses caching for dependencies (pip, npm)
7. Workflow fails fast if any job fails
8. Status badge is added to README

---

## Tasks / Subtasks

- [ ] **Task 1: Create CI Workflow File** (AC: 1, 2, 7)
  - [ ] Create `.github/workflows/ci.yaml`
  - [ ] Configure trigger:
    ```yaml
    on:
      push:
        branches: [main]
      pull_request:
        branches: [main]
    ```
  - [ ] Set `concurrency` to cancel in-progress runs on same branch
  - [ ] Configure `fail-fast: true` in job strategy (default behavior)

- [ ] **Task 2: Create API Test Job** (AC: 3, 5, 6)
  - [ ] Define `test-api` job
  - [ ] Use `ubuntu-latest` runner
  - [ ] Steps:
    1. Checkout code: `actions/checkout@v4`
    2. Set up Python 3.11: `actions/setup-python@v5`
    3. Cache pip dependencies: `actions/cache@v4` with key based on `pyproject.toml`
    4. Install dependencies: `cd apps/api && pip install -e ".[dev]"` or `pip install -e .` + dev deps
    5. Run linter: `cd apps/api && python -m flake8 src/` (or ruff if configured)
    6. Run tests: `cd apps/api && python -m pytest tests/ -v --tb=short`
  - [ ] Working directory considerations: use `working-directory: apps/api` or explicit `cd`

- [ ] **Task 3: Create Frontend Test Job** (AC: 4, 5, 6)
  - [ ] Define `test-frontend` job (runs in parallel with `test-api`)
  - [ ] Use `ubuntu-latest` runner
  - [ ] Steps:
    1. Checkout code: `actions/checkout@v4`
    2. Set up Node.js 20: `actions/setup-node@v4`
    3. Cache npm dependencies: `actions/cache@v4` with key based on `package-lock.json`
    4. Install dependencies: `cd apps/frontend && npm ci`
    5. Run linter: `cd apps/frontend && npm run lint`
    6. Run build: `cd apps/frontend && npm run build`
    7. Run tests (if configured): `cd apps/frontend && npm test -- --passWithNoTests`

- [ ] **Task 4: Add Status Badge to README** (AC: 8)
  - [ ] Add CI badge to root `README.md`:
    ```markdown
    ![CI](https://github.com/<owner>/<repo>/actions/workflows/ci.yaml/badge.svg)
    ```
  - [ ] Replace `<owner>/<repo>` with actual repository path
  - [ ] Place badge near the top of README

- [ ] **Task 5: Test Workflow** (AC: 1-8)
  - [ ] Commit and push the workflow file
  - [ ] Verify workflow triggers on push to main
  - [ ] Create a test PR to verify PR trigger
  - [ ] Verify both jobs run in parallel
  - [ ] Verify caching works on second run (check cache hit in logs)
  - [ ] Verify badge displays on README

---

## Dev Notes

### Workflow File Location

[Source: architecture/12-unified-project-structure.md]

```
.github/
└── workflows/
    ├── ci.yaml              # Build & test on PR (THIS STORY)
    ├── cd.yaml              # Build, push, deploy on main (Story 2.7/2.8)
    └── terraform.yaml       # Infrastructure changes (Story 2.9)
```

### CI/CD Pipeline Design

[Source: architecture/14-deployment-architecture.md#14.3]

**On PR:** Lint, test, build validation — this is what Story 2.6 implements.

### Tech Stack Testing Tools

[Source: architecture/3-tech-stack.md, architecture/16-testing-strategy.md]

| Component | Linter | Test Framework | Test Command |
|-----------|--------|----------------|-------------|
| API (Python) | flake8 or ruff | pytest + httpx | `pytest tests/ -v` |
| Frontend (TypeScript) | ESLint (via `npm run lint`) | Jest + RTL | `npm test` |

### Dependency Caching Patterns

**Python (pip):**
```yaml
- uses: actions/cache@v4
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('apps/api/pyproject.toml') }}
    restore-keys: |
      ${{ runner.os }}-pip-
```

**Node.js (npm):**
```yaml
- uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('apps/frontend/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
```

### Concurrency Configuration

To cancel in-progress workflow runs when a new push happens:
```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
```

### Python Version

[Source: architecture/3-tech-stack.md]
- Python 3.11+ — use `3.11` in setup-python action

### Node.js Version

[Source: architecture/3-tech-stack.md]
- Node.js 20 — use `20` in setup-node action

### Previous Story Context

From Story 1.2 (API):
- API is in `apps/api/` with `pyproject.toml`
- Tests are in `apps/api/tests/`
- Run with `pytest`

From Story 1.4 (Frontend):
- Frontend is in `apps/frontend/` with `package.json`
- Lint via `npm run lint`
- Build via `npm run build`

### Key Constraints

- **Jobs must run in parallel** (AC5) — do not use `needs` between test-api and test-frontend
- **fail-fast is default** for matrix strategies; for independent jobs, each fails independently
- **No Docker build in CI** — that's Story 2.7
- **Caching** — use `actions/cache@v4` (not `setup-python`'s built-in cache) for more control
- **Status badge URL format**: `https://github.com/{owner}/{repo}/actions/workflows/{workflow-file}/badge.svg`

### Dependencies on Previous Stories

- **Story 1.2**: API code with tests exists
- **Story 1.4**: Frontend code exists
- **No Azure dependency** — this workflow runs on GitHub runners only

---

## Testing

### Testing Requirements

| Test Type | Coverage | Method |
|-----------|----------|--------|
| E2E | Workflow triggers | Push to main / create PR |
| E2E | Job parallelism | Observe GitHub Actions UI |
| E2E | Caching | Compare first vs second run times |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **Workflow exists** — `.github/workflows/ci.yaml` is valid YAML
2. **Triggers on push** — Push to main starts workflow
3. **Triggers on PR** — Opening PR starts workflow
4. **API job passes** — Lint + pytest succeed
5. **Frontend job passes** — Lint + build succeed
6. **Jobs parallel** — Both jobs start simultaneously (check timestamps)
7. **Caching works** — Second run shows cache hit
8. **Badge renders** — README badge shows passing/failing status

### Test Commands

```bash
# Validate YAML syntax locally
python -c "import yaml; yaml.safe_load(open('.github/workflows/ci.yaml'))"

# Push to trigger
git add .github/workflows/ci.yaml
git commit -m "Add CI workflow"
git push origin main

# Check workflow status
gh run list --workflow=ci.yaml
gh run view <run-id>

# Verify badge
# Visit README on GitHub — badge should render
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-27 | 1.0 | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
