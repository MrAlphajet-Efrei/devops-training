# Story 1.8: Kubernetes Manifests for Application

## Status

**Draft**

---

## Story

**As a** DevOps engineer,
**I want** Kubernetes manifests to deploy the application to Kind,
**so that** I understand the fundamental K8s resources before using Helm.

---

## Acceptance Criteria

1. Deployment manifests exist for API and Frontend
2. StatefulSet manifest exists for PostgreSQL (or Deployment with PVC)
3. Service manifests expose each component (ClusterIP)
4. ConfigMaps manage non-sensitive configuration
5. Secrets manage database credentials (base64 encoded)
6. Resource requests and limits are defined for all containers
7. Liveness and readiness probes are configured for API
8. All resources are namespaced (e.g., `devops-demo` namespace)
9. `kubectl apply -k` or `kubectl apply -f` deploys the entire stack
10. Application is accessible via `kubectl port-forward`

---

## Tasks / Subtasks

- [ ] **Task 1: Create Manifest Directory Structure** (AC: 8, 9)
  - [ ] Create `infra/k8s/` directory
  - [ ] Create `infra/k8s/base/` for all manifest files
  - [ ] Create `infra/k8s/base/namespace.yaml` defining `devops-demo` namespace
  - [ ] Create `infra/k8s/base/kustomization.yaml` listing all resources

- [ ] **Task 2: Create Namespace** (AC: 8)
  - [ ] Define `devops-demo` namespace in `namespace.yaml`
  - [ ] All subsequent resources must set `namespace: devops-demo`

- [ ] **Task 3: Create ConfigMaps** (AC: 4)
  - [ ] Create `infra/k8s/base/api-configmap.yaml`
    - `DB_HOST: postgres`
    - `DB_PORT: "5432"`
    - `DB_NAME: devops_demo`
    - `DEBUG: "false"`
  - [ ] Create `infra/k8s/base/frontend-configmap.yaml`
    - `NEXT_PUBLIC_API_URL: http://api:8000` (internal cluster URL)

- [ ] **Task 4: Create Secrets** (AC: 5)
  - [ ] Create `infra/k8s/base/db-secret.yaml`
    - `DB_USER: base64(app_user)`
    - `DB_PASSWORD: base64(changeme)`
    - `POSTGRES_USER: base64(app_user)`
    - `POSTGRES_PASSWORD: base64(changeme)`
    - `POSTGRES_DB: base64(devops_demo)`
  - [ ] Add comment reminding that base64 is NOT encryption — this is Phase 1 (K8s Secrets)

- [ ] **Task 5: Create PostgreSQL StatefulSet** (AC: 2, 3, 6)
  - [ ] Create `infra/k8s/base/postgres-statefulset.yaml`
    - Use `postgres:15-alpine` image
    - 1 replica
    - Set env vars from `db-secret`
    - Mount `volumeClaimTemplate` for `/var/lib/postgresql/data`
    - Storage: 1Gi (sufficient for dev)
    - Resource requests: `{ memory: "128Mi", cpu: "100m" }`
    - Resource limits: `{ memory: "256Mi", cpu: "500m" }`
  - [ ] Create `infra/k8s/base/postgres-service.yaml`
    - Type: ClusterIP
    - Port: 5432 → targetPort 5432
    - Service name: `postgres` (matches DB_HOST in ConfigMap)
  - [ ] Mount `init.sql` via ConfigMap or init container (for schema initialization)

- [ ] **Task 6: Create API Deployment** (AC: 1, 3, 6, 7)
  - [ ] Create `infra/k8s/base/api-deployment.yaml`
    - Image: `devops-api:0.1.0` (loaded into Kind via `kind load`)
    - `imagePullPolicy: Never` (local Kind images)
    - 1 replica
    - Env vars from `api-configmap` (non-sensitive) and `db-secret` (credentials)
    - Liveness probe: `httpGet /health` port 8000, initialDelaySeconds 10, periodSeconds 30
    - Readiness probe: `httpGet /ready` port 8000, initialDelaySeconds 5, periodSeconds 10
    - Resource requests: `{ memory: "128Mi", cpu: "100m" }`
    - Resource limits: `{ memory: "256Mi", cpu: "500m" }`
    - Security context: `runAsUser: 1000`, `runAsNonRoot: true`, `readOnlyRootFilesystem: true`
  - [ ] Create `infra/k8s/base/api-service.yaml`
    - Type: ClusterIP
    - Port: 8000 → targetPort 8000
    - Service name: `api`

- [ ] **Task 7: Create Frontend Deployment** (AC: 1, 3, 6)
  - [ ] Create `infra/k8s/base/frontend-deployment.yaml`
    - Image: `devops-frontend:0.1.0` (loaded into Kind via `kind load`)
    - `imagePullPolicy: Never` (local Kind images)
    - 1 replica
    - Env from `frontend-configmap`
    - Resource requests: `{ memory: "64Mi", cpu: "50m" }`
    - Resource limits: `{ memory: "128Mi", cpu: "200m" }`
    - Security context: `runAsNonRoot: true`
  - [ ] Create `infra/k8s/base/frontend-service.yaml`
    - Type: ClusterIP
    - Port: 3000 → targetPort 3000
    - Service name: `frontend`

- [ ] **Task 8: Create Kustomization File** (AC: 9)
  - [ ] Create `infra/k8s/base/kustomization.yaml` listing all resources in order:
    1. namespace.yaml
    2. db-secret.yaml
    3. api-configmap.yaml
    4. frontend-configmap.yaml
    5. postgres-statefulset.yaml
    6. postgres-service.yaml
    7. api-deployment.yaml
    8. api-service.yaml
    9. frontend-deployment.yaml
    10. frontend-service.yaml

- [ ] **Task 9: Add Makefile Targets** (AC: 9, 10)
  - [ ] Add `k8s-deploy` target: `kubectl apply -k infra/k8s/base/`
  - [ ] Add `k8s-delete` target: `kubectl delete -k infra/k8s/base/`
  - [ ] Add `k8s-status` target: `kubectl get all -n devops-demo`
  - [ ] Add `k8s-load-images` target: load Docker images into Kind
  - [ ] Add `k8s-port-forward` target: port-forward API (8000) and Frontend (3000)

- [ ] **Task 10: Test Deployment** (AC: 9, 10)
  - [ ] Build Docker images (from Story 1.5)
  - [ ] Load images into Kind: `kind load docker-image devops-api:0.1.0 devops-frontend:0.1.0 --name devops-demo`
  - [ ] Deploy: `kubectl apply -k infra/k8s/base/`
  - [ ] Wait for pods to reach Running/Ready
  - [ ] Port-forward API: `kubectl port-forward svc/api 8000:8000 -n devops-demo`
  - [ ] Port-forward Frontend: `kubectl port-forward svc/frontend 3000:3000 -n devops-demo`
  - [ ] Verify `curl http://localhost:8000/health` returns healthy
  - [ ] Verify `curl http://localhost:8000/ready` returns 200 (DB connected)
  - [ ] Clean up: `kubectl delete -k infra/k8s/base/`

---

## Dev Notes

### Manifest Directory Structure

There is no explicit `infra/k8s/` directory in the unified project structure document, but this is the standard location for raw Kubernetes manifests before graduating to Helm charts (Story 1.9). The Helm charts will later live at `infra/helm/charts/`.
[Source: architecture/12-unified-project-structure.md]

```
infra/k8s/
└── base/
    ├── kustomization.yaml
    ├── namespace.yaml
    ├── db-secret.yaml
    ├── api-configmap.yaml
    ├── frontend-configmap.yaml
    ├── postgres-statefulset.yaml
    ├── postgres-service.yaml
    ├── api-deployment.yaml
    ├── api-service.yaml
    ├── frontend-deployment.yaml
    └── frontend-service.yaml
```

### Resource Limits

From the architecture security and performance document:
[Source: architecture/15-security-and-performance.md#15.3]

```yaml
# API
resources:
  requests: { memory: "128Mi", cpu: "100m" }
  limits: { memory: "256Mi", cpu: "500m" }

# Frontend
resources:
  requests: { memory: "64Mi", cpu: "50m" }
  limits: { memory: "128Mi", cpu: "200m" }
```

PostgreSQL resource limits are not specified in architecture docs. Use comparable values to API:
- Requests: `{ memory: "128Mi", cpu: "100m" }`
- Limits: `{ memory: "256Mi", cpu: "500m" }`

### Container Security Context

[Source: architecture/15-security-and-performance.md#15.1]

```yaml
securityContext:
  runAsUser: 1000
  runAsNonRoot: true
  readOnlyRootFilesystem: true    # API only — Frontend may need writable /tmp
  allowPrivilegeEscalation: false
```

**Note**: PostgreSQL needs a writable filesystem for data and write-ahead logs. Do NOT set `readOnlyRootFilesystem: true` on the PostgreSQL container. For the Frontend (Next.js), the standalone server may need a writable `/tmp` — if `readOnlyRootFilesystem` causes issues, add an `emptyDir` volume mounted at `/tmp`.

### Health Probes (API Only)

[Source: architecture/5-api-specification.md, architecture/2-high-level-architecture.md#2.5]

```yaml
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 10
  periodSeconds: 30
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 8000
  initialDelaySeconds: 5
  periodSeconds: 10
  failureThreshold: 3
```

- `/health` — returns 200 if process is alive (liveness)
- `/ready` — returns 200 if DB connected, 503 if not (readiness)

The Frontend does not have health endpoints. Use a `tcpSocket` probe on port 3000 if needed, or omit probes for the frontend in this story (AC7 specifies API only).

### Database Configuration

[Source: architecture/11-backend-architecture.md#11.4, architecture/9-database-schema.md]

API expects these environment variables:

| Variable | Sensitive | Source | Value |
|----------|-----------|--------|-------|
| `DB_HOST` | No | ConfigMap | `postgres` (K8s service name) |
| `DB_PORT` | No | ConfigMap | `5432` |
| `DB_NAME` | No | ConfigMap | `devops_demo` |
| `DB_USER` | Yes | Secret | `app_user` |
| `DB_PASSWORD` | Yes | Secret | `changeme` |
| `DEBUG` | No | ConfigMap | `false` |

PostgreSQL container expects:

| Variable | Source | Value |
|----------|--------|-------|
| `POSTGRES_USER` | Secret | `app_user` |
| `POSTGRES_PASSWORD` | Secret | `changeme` |
| `POSTGRES_DB` | Secret | `devops_demo` |

### Schema Initialization (init.sql)

The database initialization script `apps/api/db/init.sql` needs to run when PostgreSQL starts for the first time. Options:
1. **ConfigMap mount** — Create a ConfigMap from `init.sql` and mount it at `/docker-entrypoint-initdb.d/`
2. **Init container** — Copy the file from the API image

Option 1 (ConfigMap) is simpler and recommended. Create an `init-sql-configmap.yaml` from the init.sql content, or use a Kustomize `configMapGenerator` to create it from the file.

### Loading Docker Images into Kind

Kind runs its own containerd runtime and cannot access the local Docker daemon's images. Images must be explicitly loaded:
[Source: Story 1.5 Dev Agent Record — images tagged as devops-api:0.1.0 and devops-frontend:0.1.0]

```bash
# Build images first
docker build -t devops-api:0.1.0 apps/api/
docker build -t devops-frontend:0.1.0 apps/frontend/

# Load into Kind
kind load docker-image devops-api:0.1.0 --name devops-demo
kind load docker-image devops-frontend:0.1.0 --name devops-demo

# PostgreSQL is pulled from Docker Hub — Kind will pull it automatically
# OR pre-load: kind load docker-image postgres:15-alpine --name devops-demo
```

**CRITICAL**: Set `imagePullPolicy: Never` (or `IfNotPresent`) on API and Frontend deployments to prevent K8s from trying to pull from a registry.

### Secrets Phase 1 (K8s Secrets)

[Source: architecture/15-security-and-performance.md#15.1]

This story uses plain Kubernetes Secrets (base64 encoded). This is Phase 1 — Azure Key Vault integration comes in a later epic. Base64 is encoding, NOT encryption. This is acceptable for local development.

```bash
# Generate base64 values
echo -n "app_user" | base64    # YXBwX3VzZXI=
echo -n "changeme" | base64    # Y2hhbmdlbWU=
echo -n "devops_demo" | base64 # ZGV2b3BzX2RlbW8=
```

### Previous Story Insights

From Story 1.5 (Docker Containerization):
- API image: `devops-api:0.1.0`, runs as UID 1000 (`appuser`)
- Frontend image: `devops-frontend:0.1.0`, runs as non-root (`nextjs`)
- API CMD: `uvicorn app.main:app --host 0.0.0.0 --port 8000`
- Frontend CMD: `node server.js` on port 3000

From Story 1.6 (Docker Compose):
- PostgreSQL: `postgres:15-alpine`, port 5432
- init.sql mounted from `apps/api/db/init.sql`
- Service dependency order: postgres → api → frontend

From Story 1.7 (Kind Cluster):
- Cluster name: `devops-demo`
- NGINX Ingress installed (Ingress resources will be added in a future story)
- Port mappings: host 80/443 → cluster 80/443

### Key Constraints

- **`imagePullPolicy: Never`** is required for locally loaded images in Kind
- **Namespace all resources** to `devops-demo` — never use `default` namespace
- **Service names matter** — API ConfigMap uses `DB_HOST: postgres` which must match the PostgreSQL Service name
- **Frontend NEXT_PUBLIC_API_URL** — In K8s, the frontend server-side rendering calls the API via internal cluster URL (`http://api:8000`), but client-side browser calls need a different URL. For this story, use port-forward so `http://localhost:8000` works for both. Ingress will solve this properly in a later story.
- **StatefulSet for PostgreSQL** — provides stable network identity and ordered deployment, appropriate for databases even in dev

### Dependencies on Previous Stories

- **Story 1.5**: Docker images must be buildable (Dockerfiles exist)
- **Story 1.7**: Kind cluster must be running with Ingress support

---

## Testing

### Testing Requirements

| Test Type | Coverage | Method |
|-----------|----------|--------|
| E2E | Full stack deployment | kubectl apply + curl verification |
| E2E | Service connectivity | port-forward + health checks |
| E2E | Clean removal | kubectl delete + verification |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **All manifests apply cleanly** — `kubectl apply -k infra/k8s/base/` exits 0
2. **Namespace created** — `kubectl get ns devops-demo` exists
3. **PostgreSQL running** — pod in Running state, PVC bound
4. **API running** — pod in Running state, readiness probe passing
5. **Frontend running** — pod in Running state
6. **API health check** — port-forward + `curl localhost:8000/health` returns `{"status": "healthy"}`
7. **API readiness** — `curl localhost:8000/ready` returns 200 (DB connected)
8. **Frontend serves page** — port-forward + `curl localhost:3000` returns HTML
9. **Resource limits applied** — `kubectl describe pod <api-pod> -n devops-demo` shows resource limits
10. **Clean deletion** — `kubectl delete -k infra/k8s/base/` removes all resources

### Test Commands

```bash
# Prerequisite: Kind cluster running, images loaded
make kind-create
make k8s-load-images

# Deploy
make k8s-deploy
# OR: kubectl apply -k infra/k8s/base/

# Wait for pods
kubectl wait --for=condition=ready pod -l app=api -n devops-demo --timeout=120s
kubectl wait --for=condition=ready pod -l app=postgres -n devops-demo --timeout=120s

# Check status
make k8s-status
# OR: kubectl get all -n devops-demo

# Port-forward and test
kubectl port-forward svc/api 8000:8000 -n devops-demo &
kubectl port-forward svc/frontend 3000:3000 -n devops-demo &
curl http://localhost:8000/health
curl http://localhost:8000/ready
curl http://localhost:3000

# Verify resources
kubectl describe deployment api -n devops-demo | grep -A5 "Limits\|Requests"

# Clean up
make k8s-delete
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-27 | 1.0 | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
