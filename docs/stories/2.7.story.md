# Story 2.7: GitHub Actions - Docker Build & Push to ACR

## Status

**Approved**

---

## Story

**As a** DevOps engineer,
**I want** the CI pipeline to build Docker images and push to ACR,
**so that** built artifacts are available for deployment.

---

## Acceptance Criteria

1. Workflow extends `ci.yaml` or creates `cd.yaml`
2. Azure credentials are stored in GitHub Secrets
3. Workflow authenticates to ACR using `az acr login` or docker login
4. Docker images are built for API and Frontend
5. Images are tagged with git SHA and `latest`
6. Images are pushed to ACR only on `main` branch (not PRs)
7. Build uses Docker layer caching for speed
8. Workflow outputs image tags for downstream jobs

---

## Tasks / Subtasks

- [ ] **Task 1: Configure GitHub Secrets** (AC: 2)
  - [ ] In GitHub repo Settings → Secrets → Actions, add:
    - `AZURE_CLIENT_ID` — Service Principal Client ID
    - `AZURE_CLIENT_SECRET` — Service Principal Client Secret
    - `AZURE_TENANT_ID` — Tenant ID
    - `AZURE_SUBSCRIPTION_ID` — Subscription ID
    - `ACR_LOGIN_SERVER` — ACR login server URL (e.g., `acrdevopsdemo.azurecr.io`)
    - `ACR_USERNAME` — ACR admin username
    - `ACR_PASSWORD` — ACR admin password
  - [ ] Verify secrets are set (names visible, values hidden)

- [ ] **Task 2: Create CD Workflow File** (AC: 1, 6)
  - [ ] Create `.github/workflows/cd.yaml`
  - [ ] Configure trigger: push to `main` only (not PRs)
    ```yaml
    on:
      push:
        branches: [main]
    ```
  - [ ] Add concurrency control

- [ ] **Task 3: Add Build & Push Job** (AC: 3, 4, 5, 7, 8)
  - [ ] Define `build-and-push` job
  - [ ] Use `ubuntu-latest` runner
  - [ ] Steps:
    1. Checkout code: `actions/checkout@v4`
    2. Set up Docker Buildx: `docker/setup-buildx-action@v3`
    3. Login to ACR: `docker/login-action@v3` with ACR credentials from secrets
    4. Generate tags: git SHA (`${{ github.sha }}`) and `latest`
    5. Build and push API image: `docker/build-push-action@v5`
       - Context: `apps/api`
       - Tags: `<acr>/devops-api:<sha>`, `<acr>/devops-api:latest`
       - Push: true
       - Cache-from: `type=gha`
       - Cache-to: `type=gha,mode=max`
    6. Build and push Frontend image: `docker/build-push-action@v5`
       - Context: `apps/frontend`
       - Tags: `<acr>/devops-frontend:<sha>`, `<acr>/devops-frontend:latest`
       - Push: true
       - Cache-from/to: same GHA cache pattern
  - [ ] Define job outputs for image tags (used by downstream deploy job in Story 2.8)

- [ ] **Task 4: Add CI Gate** (AC: 1)
  - [ ] Option A: Add `needs: [test-api, test-frontend]` referencing CI jobs (if in same workflow)
  - [ ] Option B: If separate `cd.yaml`, use `workflow_run` trigger to run after `ci.yaml` completes
  - [ ] Recommended: Separate `cd.yaml` with `workflow_run` trigger:
    ```yaml
    on:
      workflow_run:
        workflows: ["CI"]
        types: [completed]
        branches: [main]
    ```
  - [ ] Add condition to only run if CI passed: `if: ${{ github.event.workflow_run.conclusion == 'success' }}`

- [ ] **Task 5: Define Job Outputs** (AC: 8)
  - [ ] Output the full image tags for downstream jobs:
    ```yaml
    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      image-tag: ${{ github.sha }}
    ```

- [ ] **Task 6: Test Workflow** (AC: 1-8)
  - [ ] Push workflow file to main
  - [ ] Verify CI runs first, then CD triggers
  - [ ] Verify Docker login to ACR succeeds
  - [ ] Verify images are built and pushed
  - [ ] Verify images exist in ACR: `az acr repository list --name <acr-name>`
  - [ ] Verify tags: `az acr repository show-tags --name <acr-name> --repository devops-api`
  - [ ] Verify caching works on subsequent pushes

---

## Dev Notes

### Workflow Architecture

[Source: architecture/12-unified-project-structure.md, architecture/14-deployment-architecture.md#14.3]

```
.github/workflows/
├── ci.yaml        # Story 2.6 — build & test on PR + push
├── cd.yaml        # THIS STORY — build Docker, push to ACR (main only)
└── terraform.yaml # Story 2.9 — infrastructure pipeline
```

Pipeline flow on merge to main:
1. CI workflow runs (lint, test, build validation)
2. CD workflow triggers after CI succeeds
3. CD builds Docker images → pushes to ACR with SHA tag
4. (Story 2.8) Deploy to K8s environment

### Docker Build & Push Action Pattern

```yaml
- uses: docker/build-push-action@v5
  with:
    context: apps/api
    push: true
    tags: |
      ${{ secrets.ACR_LOGIN_SERVER }}/devops-api:${{ github.sha }}
      ${{ secrets.ACR_LOGIN_SERVER }}/devops-api:latest
    cache-from: type=gha
    cache-to: type=gha,mode=max
```

### ACR Login Pattern

```yaml
- uses: docker/login-action@v3
  with:
    registry: ${{ secrets.ACR_LOGIN_SERVER }}
    username: ${{ secrets.ACR_USERNAME }}
    password: ${{ secrets.ACR_PASSWORD }}
```

### Image Tagging Strategy

[Source: architecture/14-deployment-architecture.md#14.3]

- **Git SHA tag**: `devops-api:<sha>` — immutable, traceable to exact commit
- **Latest tag**: `devops-api:latest` — always points to most recent build
- Tags match the deployment architecture spec: "Push to ACR with SHA tag"

### Docker Images from Story 1.5

- API Dockerfile: `apps/api/Dockerfile` (multi-stage, python:3.11-slim)
- Frontend Dockerfile: `apps/frontend/Dockerfile` (multi-stage, node:20-alpine)
- API image locally tagged as: `devops-api:0.1.0`
- Frontend image locally tagged as: `devops-frontend:0.1.0`

In ACR, names become: `<acr-server>/devops-api:<tag>` and `<acr-server>/devops-frontend:<tag>`

### GitHub Actions Docker Cache

GHA cache (`type=gha`) stores Docker layer cache in GitHub Actions cache storage. This significantly speeds up subsequent builds by reusing unchanged layers.

### Key Constraints

- **Push only on main** (AC6) — PRs should NOT push images
- **`workflow_run` trigger** is recommended over combining CI+CD in one file — better separation of concerns
- **`workflow_run` requires the CI workflow name** to match exactly
- **GitHub Secrets are not available to forks** — this is fine for this project
- **Docker Buildx** is required for GHA cache support
- **ACR admin credentials** are used for simplicity — production would use SP or managed identity

### Dependencies on Previous Stories

- **Story 2.1**: Service Principal credentials for Azure
- **Story 2.3**: ACR exists in Azure
- **Story 2.6**: CI workflow exists (CD triggers after CI)

---

## Testing

### Testing Requirements

| Test Type | Coverage | Method |
|-----------|----------|--------|
| E2E | Workflow trigger | Push to main |
| E2E | ACR push | az acr repository list |
| E2E | Image tags | az acr repository show-tags |

[Source: architecture/16-testing-strategy.md — E2E: curl smoke tests]

### Test Scenarios

1. **CD triggers after CI** — workflow_run fires on CI completion
2. **ACR login succeeds** — Login step passes
3. **API image built and pushed** — `az acr repository show-tags --repository devops-api` shows SHA tag
4. **Frontend image built and pushed** — `az acr repository show-tags --repository devops-frontend` shows SHA tag
5. **Latest tag exists** — Both repos have `latest` tag
6. **No push on PR** — Creating a PR does NOT push images
7. **Cache used on second run** — Build step shows cache hits

### Test Commands

```bash
# Push to trigger
git push origin main

# Check workflow
gh run list --workflow=cd.yaml
gh run view <run-id>

# Verify images in ACR
az acr repository list --name <acr-name> -o table
az acr repository show-tags --name <acr-name> --repository devops-api -o table
az acr repository show-tags --name <acr-name> --repository devops-frontend -o table
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-27 | 1.0 | Initial story draft | SM Bob |

---

## Dev Agent Record

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
